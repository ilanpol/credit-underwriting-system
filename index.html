/**
 * ××¢×¨×›×ª ×˜×¢×™× ×ª ×§×‘×¦×™× ××ª×§×“××ª
 * ××˜×¤×œ ×‘×”×¢×œ××”, ××™××•×ª ×•×¢×™×‘×•×“ ×©×œ ×§×‘×¦×™ × ×ª×•× ×™× ×¢×¡×§×™×™× ××•×¨×›×‘×™×
 */

class EnhancedFileLoader {
    constructor() {
        this.supportedFormats = ['.xlsx', '.xls', '.csv'];
        this.maxFileSize = 100 * 1024 * 1024; // 100MB ×œ××¢×¨×›×•×ª ×¢×¡×§×™×•×ª
        this.currentFile = null;
        this.uploadProgress = 0;
        this.expectedHeaders = this.initializeExpectedHeaders();
        this.init();
    }

    // ğŸš€ ××ª×—×•×œ
    init() {
        this.setupEventListeners();
        this.setupDragAndDrop();
        console.log('ğŸ“ ××¢×¨×›×ª ×˜×¢×™× ×ª ×§×‘×¦×™× ××ª×§×“××ª ×”×•×ª×—×œ×”');
    }

    // ğŸ“‹ ×¨×©×™××ª ×›×•×ª×¨×•×ª ×¦×¤×•×™×•×ª
    initializeExpectedHeaders() {
        return [
            // ×¢××•×“×•×ª ×‘×¡×™×¡×™×•×ª
            '×¡×•×’ ×¢×™×¡×§×”', '×©× ×œ×§×•×—', '×.×–×”×•×ª', '×ª×—×•× ×¢×™×¡×•×§ ×œ×§×•×—',
            '××¡×¤×¨ ×©×™×§', '××–×”×” ×©×™×§', '×‘-×¡-×—', '×©× ××•×©×š', '××¡×¤×¨ ×–×”×•×ª ××•×©×š',
            
            // ×¤×¨×˜×™ ×§×©×¨
            '×˜×œ×¤×•×Ÿ 1 ××•×©×š', '×˜×œ×¤×•×Ÿ 2 ××•×©×š', '×›×ª×•×‘×ª ××•×©×š',
            
            // ×ª××¨×™×›×™×
            '×ª.×¤×™×¨×¢×•×Ÿ', '×ª.×¤×¨×¢×•×Ÿ ×‘×¤×•×¢×œ', '×ª××¨×™×š ×”×¤×§×“×”/××¡×™×¨×”', '×ª××¨×™×š ×”×©×‘×”',
            
            // × ×ª×•× ×™× ×¤×™× × ×¡×™×™×
            '×¡×›×•×', '×™×ª×¨×”', '×¢××œ×”', '××—×•×– ×¢××œ×”', '××—×•×– ×¢××œ×” - ×—×œ×§×™',
            '××—×•×– ×”×©×ª×ª×¤×•×ª', '××—×•×– ×¨×•×•×—',
            
            // ××™×“×¢ × ×•×¡×£
            '×©× ××•×˜×‘', '×¡×˜×˜×•×¡', '×™×¢×“', '××™×© ××›×™×¨×•×ª', '×§×˜×’×•×¨×™×”',
            '×ª×—×•× ×¢×™×¡×•×§ ××•×©×š', '××•××œ×¥ ×œ×’×‘×™×™×”', '× ×¦×™×’ ×©×™×¨×•×ª'
        ];
    }

    // ğŸ¯ ×”×’×“×¨×ª ×××–×™× ×™ ××™×¨×•×¢×™×
    setupEventListeners() {
        // ××™×¨×•×¢×™ ×§×‘×¦×™× ××¨×•×‘×™×
        const fileInputs = [
            'mainExcelFile', 'scoresFile', 'returnedFile', 'warningsFile'
        ];
        
        fileInputs.forEach(inputId => {
            const input = document.getElementById(inputId);
            if (input) {
                input.addEventListener('change', (e) => this.handleFileInput(e, inputId));
            }
        });
    }

    // ğŸ–±ï¸ ×”×’×“×¨×ª Drag & Drop
    setupDragAndDrop() {
        const uploadAreas = document.querySelectorAll('.upload-area, .excel-upload-section');
        
        uploadAreas.forEach(area => {
            area.addEventListener('dragover', (e) => this.handleDragOver(e));
            area.addEventListener('drop', (e) => this.handleDrop(e));
            area.addEventListener('dragenter', (e) => this.handleDragEnter(e));
            area.addEventListener('dragleave', (e) => this.handleDragLeave(e));
        });
    }

    // ğŸ“¤ ×”×¢×œ××ª ×§×•×‘×¥ ×¢× ×ª××™×›×” ×‘×¤×•×¨××˜×™× ××¨×•×‘×™×
    async uploadFile(file, progressCallback = null, fileType = 'main') {
        try {
            // ××™××•×ª ×§×•×‘×¥
            const validation = this.validateFile(file);
            if (!validation.isValid) {
                throw new Error(validation.error);
            }

            this.currentFile = file;
            this.uploadProgress = 0;

            console.log(`ğŸ“ ××ª×—×™×œ ×‘×˜×¢×™× ×ª ×§×•×‘×¥: ${file.name} (${fileType})`);

            // ×¢×“×›×•×Ÿ ×ª×¦×•×’×ª ×”×ª×§×“××•×ª
            if (progressCallback) {
                progressCallback(0, `××ª×—×™×œ ×‘×˜×¢×™× ×ª ${file.name}...`);
            }

            // ×§×¨×™××ª ×”×§×•×‘×¥
            const fileData = await this.readFile(file, progressCallback);
            
            // ×–×™×”×•×™ ×¡×•×’ ×§×•×‘×¥ ×•×¢×™×‘×•×“ ××ª××™×
            if (progressCallback) {
                progressCallback(70, '××¢×‘×“ × ×ª×•× ×™×...');
            }

            const processedData = await this.processFileData(fileData, file, fileType);
            
            // ××™××•×ª × ×ª×•× ×™×
            const validation_result = this.validateProcessedData(processedData);
            if (!validation_result.isValid) {
                console.warn('âš ï¸ ××–×”×¨×•×ª ×‘××™××•×ª × ×ª×•× ×™×:', validation_result.warnings);
            }

            if (progressCallback) {
                progressCallback(100, '×”×˜×¢×™× ×” ×”×•×©×œ××” ×‘×”×¦×œ×—×”!');
            }

            // ×¨×™×©×•× ×¤×¢×™×œ×•×ª
            if (window.authManager) {
                window.authManager.logActivity('file_upload', 
                    `×”×•×¢×œ×” ×§×•×‘×¥: ${file.name} (${this.formatFileSize(file.size)}) - ×¡×•×’: ${fileType}`);
            }

            return {
                success: true,
                data: processedData,
                file: file,
                fileType: fileType,
                summary: this.generateDataSummary(processedData),
                validation: validation_result
            };

        } catch (error) {
            console.error('âŒ ×©×’×™××” ×‘×”×¢×œ××ª ×§×•×‘×¥:', error);
            
            if (window.authManager) {
                window.authManager.logActivity('file_upload_error', 
                    `×©×’×™××” ×‘×”×¢×œ××ª ×§×•×‘×¥: ${error.message}`);
            }

            return {
                success: false,
                error: error.message,
                fileType: fileType
            };
        }
    }

    // âœ… ××™××•×ª ×§×•×‘×¥ ××ª×§×“×
    validateFile(file) {
        // ×‘×“×™×§×ª ×§×™×•× ×§×•×‘×¥
        if (!file) {
            return { isValid: false, error: '×œ× × ×‘×—×¨ ×§×•×‘×¥' };
        }

        // ×‘×“×™×§×ª ×’×•×“×œ ×§×•×‘×¥
        if (file.size > this.maxFileSize) {
            return { 
                isValid: false, 
                error: `×’×•×“×œ ×”×§×•×‘×¥ ×—×•×¨×’ ××”××•×ª×¨ (××§×¡×™××•×: ${this.formatFileSize(this.maxFileSize)})` 
            };
        }

        // ×‘×“×™×§×ª ×¡×•×’ ×§×•×‘×¥
        const fileExtension = this.getFileExtension(file.name);
        if (!this.supportedFormats.includes(fileExtension)) {
            return { 
                isValid: false, 
                error: `×¡×•×’ ×§×•×‘×¥ ×œ× × ×ª××š. ×¡×•×’×™× × ×ª××›×™×: ${this.supportedFormats.join(', ')}` 
            };
        }

        // ×‘×“×™×§×ª ×”×¨×©××•×ª
        if (window.authManager && !window.authManager.hasPermission('write')) {
            return { 
                isValid: false, 
                error: '××™×Ÿ ×”×¨×©××” ×œ×”×¢×œ×•×ª ×§×‘×¦×™×' 
            };
        }

        // ×‘×“×™×§×ª ×©× ×§×•×‘×¥ (×× ×™×¢×ª ×ª×•×•×™× ××™×•×—×“×™×)
        const invalidChars = /[<>:"/\\|?*]/;
        if (invalidChars.test(file.name)) {
            return {
                isValid: false,
                error: '×©× ×”×§×•×‘×¥ ××›×™×œ ×ª×•×•×™× ×œ× ×—×•×§×™×™×'
            };
        }

        return { isValid: true };
    }

    // ğŸ“– ×§×¨×™××ª ×§×•×‘×¥ ××ª×§×“××ª
    async readFile(file, progressCallback = null) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            const fileExtension = this.getFileExtension(file.name);
            
            reader.onload = (e) => {
                try {
                    if (progressCallback) {
                        progressCallback(60, '×§×•×‘×¥ × ×§×¨× ×‘×”×¦×œ×—×”, ××¤×¨×¡×¨ × ×ª×•× ×™×...');
                    }
                    resolve(e.target.result);
                } catch (error) {
                    reject(new Error(`×©×’×™××” ×‘×¤×¨×¡×•×¨ ×§×•×‘×¥: ${error.message}`));
                }
            };
            
            reader.onerror = () => {
                reject(new Error('×©×’×™××” ×‘×§×¨×™××ª ×”×§×•×‘×¥'));
            };
            
            reader.onprogress = (e) => {
                if (e.lengthComputable && progressCallback) {
                    const progress = Math.round((e.loaded / e.total) * 50); // 50% ××”×”×ª×§×“××•×ª ×œ×§×¨×™××”
                    progressCallback(progress, '×§×•×¨× ×§×•×‘×¥...');
                }
            };

            // ×‘×—×™×¨×ª ×©×™×˜×ª ×§×¨×™××” ×œ×¤×™ ×¡×•×’ ×”×§×•×‘×¥
            if (fileExtension === '.csv') {
                reader.readAsText(file, 'UTF-8');
            } else if (fileExtension === '.xlsx' || fileExtension === '.xls') {
                reader.readAsArrayBuffer(file);
            } else {
                reader.readAsText(file, 'UTF-8');
            }
        });
    }

    // ğŸ”„ ×¢×™×‘×•×“ × ×ª×•× ×™ ×§×•×‘×¥ ××ª×§×“×
    async processFileData(fileData, file, fileType) {
        const fileExtension = this.getFileExtension(file.name);
        
        let processedData;
        switch (fileExtension) {
            case '.csv':
                processedData = await this.processCSV(fileData, file);
                break;
            case '.xlsx':
            case '.xls':
                processedData = await this.processExcel(fileData, file, fileType);
                break;
            default:
                throw new Error('×¡×•×’ ×§×•×‘×¥ ×œ× × ×ª××š');
        }

        // ×”×•×¡×£ ××˜××“×˜×”
        processedData.metadata = {
            fileName: file.name,
            fileSize: file.size,
            fileType: fileType,
            uploadTime: new Date(),
            fileExtension: fileExtension
        };

        return processedData;
    }

    // ğŸ“Š ×¢×™×‘×•×“ ×§×•×‘×¥ Excel ××ª×§×“×
    async processExcel(excelData, file, fileType) {
        try {
            // ×‘×“×•×§ ×× XLSX ×–××™×Ÿ
            if (typeof XLSX === 'undefined') {
                throw new Error('×¡×¤×¨×™×™×ª XLSX ×œ× × ×˜×¢× ×”. × × ×œ×˜×¢×•×Ÿ ×§×•×‘×¥ CSV ×‘××§×•×.');
            }

            console.log('ğŸ“Š ××¢×‘×“ ×§×•×‘×¥ Excel...');
            
            const workbook = XLSX.read(excelData, { 
                type: 'array',
                cellStyles: true,
                cellFormulas: true,
                cellDates: true,
                cellNF: true,
                sheetStubs: true
            });

            console.log('ğŸ“‹ ×’×™×œ×™×•× ×•×ª ×–××™× ×™×:', workbook.SheetNames);

            // ×§×‘×™×¢×ª ××™×–×” ×’×™×œ×™×•×Ÿ ×œ×§×¨×•×
            let sheetName;
            if (fileType === 'main' && workbook.SheetNames.includes('×’×™×œ×™×•×Ÿ1')) {
                sheetName = '×’×™×œ×™×•×Ÿ1';
            } else if (workbook.SheetNames.length > 0) {
                sheetName = workbook.SheetNames[0];
            } else {
                throw new Error('×œ× × ××¦××• ×’×™×œ×™×•× ×•×ª ×‘×§×•×‘×¥');
            }

            console.log(`ğŸ“„ ×§×•×¨× ×’×™×œ×™×•×Ÿ: ${sheetName}`);

            const worksheet = workbook.Sheets[sheetName];
            
            // ×”××¨×” ×œ-JSON ×¢× ×©××™×¨×ª ×”×›×•×ª×¨×•×ª
            const jsonData = XLSX.utils.sheet_to_json(worksheet, { 
                header: 1,
                defval: '',
                blankrows: false
            });

            if (jsonData.length === 0) {
                throw new Error('×”×’×™×œ×™×•×Ÿ ×¨×™×§ ××• ×œ× ××›×™×œ × ×ª×•× ×™×');
            }

            // ×”×›×•×ª×¨×•×ª ×”×Ÿ ×”×©×•×¨×” ×”×¨××©×•× ×”
            const headers = jsonData[0].map(header => 
                header ? header.toString().trim() : ''
            ).filter(header => header !== '');

            // ×”× ×ª×•× ×™× ×”× ×”×©×•×¨×•×ª ×”×‘××•×ª
            const dataRows = jsonData.slice(1);
            
            // ×”××¨×ª ×”×©×•×¨×•×ª ×œ××•×‘×™×™×§×˜×™×
            const data = dataRows
                .filter(row => row && row.some(cell => cell !== null && cell !== ''))
                .map((row, index) => {
                    const rowObject = {};
                    headers.forEach((header, colIndex) => {
                        if (header && colIndex < row.length) {
                            let value = row[colIndex];
                            
                            // ×˜×™×¤×•×œ ××™×•×—×“ ×‘×ª××¨×™×›×™× ×©×œ Excel
                            if (typeof value === 'number' && this.isExcelDate(value)) {
                                value = this.excelDateToJSDate(value);
                            }
                            
                            rowObject[header] = value !== null && value !== undefined ? value : '';
                        }
                    });
                    rowObject._rowIndex = index + 2; // +2 ×›×™ ×× ×—× ×• ××ª×—×™×œ×™× ××©×•×¨×” 2
                    return rowObject;
                });

            console.log(`âœ… ×¢×•×‘×“×• ${data.length} ×¨×©×•××•×ª ××§×•×‘×¥ Excel`);

            return {
                headers: headers,
                data: data,
                rowCount: data.length,
                fileName: file.name,
                fileSize: file.size,
                fileType: 'Excel',
                sheetName: sheetName,
                availableSheets: workbook.SheetNames
            };

        } catch (error) {
            console.error('âŒ ×©×’×™××” ×‘×¢×™×‘×•×“ Excel:', error);
            throw new Error(`×©×’×™××” ×‘×¢×™×‘×•×“ ×§×•×‘×¥ Excel: ${error.message}`);
        }
    }

    // ğŸ“Š ×¢×™×‘×•×“ ×§×•×‘×¥ CSV ××ª×§×“×
    async processCSV(csvData, file) {
        try {
            console.log('ğŸ“Š ××¢×‘×“ ×§×•×‘×¥ CSV...');

            // × ×™×¡×•×™ ×œ×–×”×•×ª encoding
            const encoding = this.detectCSVEncoding(csvData);
            console.log(`ğŸ”¤ ×–×™×”×•×™ ×§×™×“×•×“: ${encoding}`);

            let processedData;

            // ×× Papa Parse ×–××™×Ÿ, ×”×©×ª××© ×‘×•
            if (typeof Papa !== 'undefined') {
                const result = Papa.parse(csvData, {
                    header: true,
                    dynamicTyping: true,
                    skipEmptyLines: true,
                    delimitersToGuess: [',', '\t', ';', '|'],
                    encoding: 'UTF-8',
                    error: function(err) {
                        console.warn('âš ï¸ ××–×”×¨×ª Papa Parse:', err);
                    }
                });

                if (result.errors && result.errors.length > 0) {
                    console.warn('âš ï¸ ×©×’×™××•×ª ×‘×¤×¨×¡×•×¨ CSV:', result.errors);
                }

                processedData = {
                    headers: result.meta.fields || [],
                    data: result.data,
                    rowCount: result.data.length,
                    errors: result.errors
                };

            } else {
                // ×¤×¨×¡×•×¨ ×™×“× ×™ ×× Papa Parse ×œ× ×–××™×Ÿ
                const lines = csvData.split('\n');
                const headers = this.parseCSVLine(lines[0]);
                const data = [];

                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (line) {
                        const values = this.parseCSVLine(line);
                        const row = {};
                        
                        headers.forEach((header, index) => {
                            row[header.trim()] = values[index] ? values[index].trim() : '';
                        });
                        
                        row._rowIndex = i + 1;
                        data.push(row);
                    }
                }

                processedData = {
                    headers: headers,
                    data: data,
                    rowCount: data.length
                };
            }

            console.log(`âœ… ×¢×•×‘×“×• ${processedData.rowCount} ×¨×©×•××•×ª ××§×•×‘×¥ CSV`);

            return {
                ...processedData,
                fileName: file.name,
                fileSize: file.size,
                fileType: 'CSV'
            };

        } catch (error) {
            console.error('âŒ ×©×’×™××” ×‘×¢×™×‘×•×“ CSV:', error);
            throw new Error(`×©×’×™××” ×‘×¢×™×‘×•×“ ×§×•×‘×¥ CSV: ${error.message}`);
        }
    }

    // ğŸ“… ×¤×•× ×§×¦×™×•×ª ×¢×–×¨ ×œ×ª××¨×™×›×™ Excel
    isExcelDate(value) {
        // ×‘×“×•×§ ×× ×–×” ××¡×¤×¨ ×©×™×›×•×œ ×œ×”×™×•×ª ×ª××¨×™×š Excel
        return typeof value === 'number' && 
               value > 0 && 
               value < 2958466 && // ×ª××¨×™×š ××§×¡×™××œ×™ ×©×œ Excel
               value % 1 !== 0; // ×œ× ××¡×¤×¨ ×©×œ×
    }

    excelDateToJSDate(excelDate) {
        // Excel ××—×©×™×‘ ×ª××¨×™×›×™× ×-1/1/1900
        const excelEpoch = new Date(1899, 11, 30); // 30/12/1899
        const jsDate = new Date(excelEpoch.getTime() + excelDate * 24 * 60 * 60 * 1000);
        return jsDate;
    }

    // ğŸ”¤ ×–×™×”×•×™ ×§×™×“×•×“ CSV
    detectCSVEncoding(csvData) {
        // ×‘×“×™×§×” ×¤×©×•×˜×” ×œ×ª×•×•×™× ×¢×‘×¨×™×™×
        const hebrewPattern = /[\u0590-\u05FF]/;
        if (hebrewPattern.test(csvData)) {
            return 'UTF-8';
        }
        return 'UTF-8'; // ×‘×¨×™×¨×ª ××—×“×œ
    }

    // ğŸ”§ ×¤×™×¦×•×œ ×©×•×¨×ª CSV ××ª×§×“×
    parseCSVLine(line) {
        const result = [];
        let current = '';
        let inQuotes = false;
        let quoteChar = null;
        
        for (let i = 0; i < line.length; i++) {
            const char = line[i];
            
            if (!inQuotes) {
                if (char === '"' || char === "'") {
                    inQuotes = true;
                    quoteChar = char;
                } else if (char === ',' || char === ';' || char === '\t') {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            } else {
                if (char === quoteChar) {
                    if (i + 1 < line.length && line[i + 1] === quoteChar) {
                        // ××¨×›××” ×›×¤×•×œ×” - ×”×•×¡×£ ××¨×›××” ××—×ª
                        current += quoteChar;
                        i++; // ×“×œ×’ ×¢×œ ×”××¨×›××” ×”×‘××”
                    } else {
                        // ×¡×•×£ ×”××—×¨×•×–×ª ×‘××¨×›××•×ª
                        inQuotes = false;
                        quoteChar = null;
                    }
                } else {
                    current += char;
                }
            }
        }
        
        result.push(current.trim());
        return result.filter(item => item !== ''); // ×”×¡×¨ ×¢×¨×›×™× ×¨×™×§×™×
    }

    // âœ… ××™××•×ª × ×ª×•× ×™× ××¢×•×‘×“×™×
    validateProcessedData(data) {
        const warnings = [];
        const errors = [];

        // ×‘×“×™×§×ª ×§×™×•× × ×ª×•× ×™×
        if (!data.data || data.data.length === 0) {
            errors.push('××™×Ÿ × ×ª×•× ×™× ×‘×§×•×‘×¥');
        }

        // ×‘×“×™×§×ª ×›×•×ª×¨×•×ª
        if (!data.headers || data.headers.length === 0) {
            errors.push('×œ× × ××¦××• ×›×•×ª×¨×•×ª ×‘×§×•×‘×¥');
        } else {
            // ×‘×“×•×§ ×× ×™×© ×›×•×ª×¨×•×ª ×¨×™×§×•×ª
            const emptyHeaders = data.headers.filter(h => !h || h.trim() === '');
            if (emptyHeaders.length > 0) {
                warnings.push(`${emptyHeaders.length} ×›×•×ª×¨×•×ª ×¨×™×§×•×ª × ××¦××•`);
            }

            // ×‘×“×•×§ ×”×ª×××” ×œ×›×•×ª×¨×•×ª ×¦×¤×•×™×•×ª
            const matchingHeaders = data.headers.filter(header => 
                this.expectedHeaders.some(expected => 
                    header.includes(expected) || expected.includes(header)
                )
            );

            const matchPercentage = (matchingHeaders.length / this.expectedHeaders.length) * 100;
            if (matchPercentage < 30) {
                warnings.push(`×¨×§ ${matchPercentage.toFixed(1)}% ××”×›×•×ª×¨×•×ª ××–×•×”×•×ª ×›×¦×¤×•×™×•×ª`);
            }
        }

        // ×‘×“×™×§×ª ××™×›×•×ª × ×ª×•× ×™×
        if (data.data && data.data.length > 0) {
            const firstRow = data.data[0];
            const emptyFields = Object.keys(firstRow).filter(key => 
                !firstRow[key] || firstRow[key].toString().trim() === ''
            ).length;
            
            if (emptyFields > Object.keys(firstRow).length * 0.5) {
                warnings.push('×©×™×¢×•×¨ ×’×‘×•×” ×©×œ ×©×“×•×ª ×¨×™×§×™× ×‘× ×ª×•× ×™×');
            }

            // ×‘×“×™×§×ª ×©×•×¨×•×ª ×›×¤×•×œ×•×ª
            const duplicateCheck = this.findDuplicateRows(data.data);
            if (duplicateCheck.duplicates > 0) {
                warnings.push(`× ××¦××• ${duplicateCheck.duplicates} ×©×•×¨×•×ª ×›×¤×•×œ×•×ª ××¤×©×¨×™×•×ª`);
            }
        }

        // ×‘×“×™×§×ª ×’×•×“×œ × ×ª×•× ×™×
        if (data.rowCount > 50000) {
            warnings.push('×§×•×‘×¥ ×’×“×•×œ ×××•×“ - ×‘×™×¦×•×¢×™× ×¢×œ×•×œ×™× ×œ×”×™×¤×’×¢');
        }

        return {
            isValid: errors.length === 0,
            errors: errors,
            warnings: warnings,
            quality: {
                headerMatch: matchingHeaders ? (matchingHeaders.length / this.expectedHeaders.length) * 100 : 0,
                dataCompleteness: this.calculateDataCompleteness(data),
                duplicateRows: duplicateCheck ? duplicateCheck.duplicates : 0
            }
        };
    }

    // ğŸ” ××¦×™××ª ×©×•×¨×•×ª ×›×¤×•×œ×•×ª
    findDuplicateRows(data) {
        const seen = new Set();
        let duplicates = 0;

        data.forEach(row => {
            // ×™×¦×™×¨×ª ××–×”×” ×™×™×—×•×“×™ ×¢×œ ×‘×¡×™×¡ ×©×“×•×ª ××¨×›×–×™×™×
            const key = `${row['××¡×¤×¨ ×–×”×•×ª ××•×©×š'] || ''}_${row['×¡×›×•×'] || ''}_${row['×ª××¨×™×š ×”×¤×§×“×”/××¡×™×¨×”'] || ''}`;
            
            if (seen.has(key)) {
                duplicates++;
            } else {
                seen.add(key);
            }
        });

        return { duplicates, total: data.length };
    }

    // ğŸ“Š ×—×™×©×•×‘ ×©×œ××•×ª × ×ª×•× ×™×
    calculateDataCompleteness(data) {
        if (!data.data || data.data.length === 0) return 0;

        const importantFields = [
            '×©× ××•×©×š', '××¡×¤×¨ ×–×”×•×ª ××•×©×š', '×¡×›×•×', '×ª××¨×™×š ×”×¤×§×“×”/××¡×™×¨×”', '×¡×˜×˜×•×¡'
        ];

        let completedFields = 0;
        let totalFields = 0;

        data.data.forEach(row => {
            importantFields.forEach(field => {
                totalFields++;
                if (row[field] && row[field].toString().trim() !== '') {
                    completedFields++;
                }
            });
        });

        return totalFields > 0 ? (completedFields / totalFields) * 100 : 0;
    }

    // ğŸ“Š ×™×¦×™×¨×ª ×¡×™×›×•× × ×ª×•× ×™× ××ª×§×“×
    generateDataSummary(processedData) {
        const summary = {
            basicInfo: {
                totalRows: processedData.rowCount,
                totalColumns: processedData.headers ? processedData.headers.length : 0,
                fileName: processedData.fileName,
                fileSize: this.formatFileSize(processedData.fileSize),
                fileType: processedData.fileType,
                uploadTime: new Date()
            },
            
            columnAnalysis: [],
            dataQuality: {
                completeness: this.calculateDataCompleteness(processedData),
                consistency: 0, // ×™×—×•×©×‘ ×‘×”××©×š
                accuracy: 0 // ×™×—×•×©×‘ ×‘×”××©×š
            },
            
            preview: processedData.data.slice(0, 5), // 5 ×©×•×¨×•×ª ×¨××©×•× ×•×ª
            
            insights: []
        };

        // × ×™×ª×•×— ×¢××•×“×•×ª
        if (processedData.headers) {
            summary.columnAnalysis = processedData.headers.map(header => ({
                name: header,
                type: this.detectColumnType(processedData.data, header),
                sampleValues: this.getSampleValues(processedData.data, header),
                nullCount: this.countNullValues(processedData.data, header),
                uniqueValues: this.countUniqueValues(processedData.data, header)
            }));
        }

        // ×–×™×”×•×™ ×¢××•×“×•×ª ××¨×›×–×™×•×ª
        const keyColumns = this.identifyKeyColumns(processedData);
        summary.keyColumns = keyColumns;

        // ×ª×•×‘× ×•×ª ××•×˜×•××˜×™×•×ª
        summary.insights = this.generateAutomaticInsights(processedData, summary);

        return summary;
    }

    // ğŸ” ×–×™×”×•×™ ×¢××•×“×•×ª ××¨×›×–×™×•×ª
    identifyKeyColumns(data) {
        const keyColumns = {};
        
        if (data.headers) {
            // ×–×™×”×•×™ ×¢××•×“×ª ××–×”×” ××•×©×š
            const payerIdColumn = data.headers.find(h => 
                h.includes('××¡×¤×¨ ×–×”×•×ª ××•×©×š') || h.includes('××•×©×š') || h.includes('×–×”×•×ª')
            );
            if (payerIdColumn) keyColumns.payerId = payerIdColumn;

            // ×–×™×”×•×™ ×¢××•×“×ª ×¡×›×•×
            const amountColumn = data.headers.find(h => 
                h.includes('×¡×›×•×') || h.includes('amount')
            );
            if (amountColumn) keyColumns.amount = amountColumn;

            // ×–×™×”×•×™ ×¢××•×“×ª ×ª××¨×™×š
            const dateColumn = data.headers.find(h => 
                h.includes('×ª××¨×™×š') || h.includes('date') || h.includes('×¤×§×“×”')
            );
            if (dateColumn) keyColumns.date = dateColumn;

            // ×–×™×”×•×™ ×¢××•×“×ª ×¡×˜×˜×•×¡
            const statusColumn = data.headers.find(h => 
                h.includes('×¡×˜×˜×•×¡') || h.includes('status')
            );
            if (statusColumn) keyColumns.status = statusColumn;
        }

        return keyColumns;
    }

    // ğŸ’¡ ×™×¦×™×¨×ª ×ª×•×‘× ×•×ª ××•×˜×•××˜×™×•×ª
    generateAutomaticInsights(data, summary) {
        const insights = [];

        // ×ª×•×‘× ×” ×¢×œ ×’×•×“×œ ×”×§×•×‘×¥
        if (data.rowCount > 10000) {
            insights.push({
                type: 'size',
                message: `×§×•×‘×¥ ×’×“×•×œ ×¢× ${data.rowCount.toLocaleString()} ×¨×©×•××•×ª`,
                recommendation: '××•××œ×¥ ×œ×¤×¨×§ ×œ×§×‘×¦×™× ×§×˜× ×™× ×™×•×ª×¨ ×œ×‘×™×¦×•×¢×™× ×˜×•×‘×™× ×™×•×ª×¨'
            });
        }

        // ×ª×•×‘× ×” ×¢×œ ××™×›×•×ª × ×ª×•× ×™×
        if (summary.dataQuality.completeness < 80) {
            insights.push({
                type: 'quality',
                message: `××™×›×•×ª × ×ª×•× ×™× × ××•×›×”: ${summary.dataQuality.completeness.toFixed(1)}% ×©×œ××•×ª`,
                recommendation: '××•××œ×¥ ×œ×‘×“×•×§ ×•×œ×”×©×œ×™× × ×ª×•× ×™× ×—×¡×¨×™×'
            });
        }

        // ×ª×•×‘× ×” ×¢×œ ×¢××•×“×•×ª ××¨×›×–×™×•×ª
        const missingKeyColumns = [];
        const expectedKeys = ['payerId', 'amount', 'date'];
        expectedKeys.forEach(key => {
            if (!summary.keyColumns || !summary.keyColumns[key]) {
                missingKeyColumns.push(key);
            }
        });

        if (missingKeyColumns.length > 0) {
            insights.push({
                type: 'structure',
                message: `×¢××•×“×•×ª ××¨×›×–×™×•×ª ×—×¡×¨×•×ª: ${missingKeyColumns.join(', ')}`,
                recommendation: '×•×“× ×©×”×§×•×‘×¥ ××›×™×œ ××ª ×›×œ ×”×©×“×•×ª ×”× ×“×¨×©×™×'
            });
        }

        return insights;
    }

    // ğŸ”§ ×¤×•× ×§×¦×™×•×ª ×¢×–×¨ × ×•×¡×¤×•×ª

    detectColumnType(data, columnName) {
        if (!data || data.length === 0) return 'unknown';
        
        const sampleSize = Math.min(10, data.length);
        const samples = data.slice(0, sampleSize)
            .map(row => row[columnName])
            .filter(value => value !== null && value !== undefined && value !== '');

        if (samples.length === 0) return 'empty';

        let numberCount = 0;
        let dateCount = 0;
        let booleanCount = 0;

        samples.forEach(value => {
            const strValue = value.toString().toLowerCase();
            
            // ×‘×“×™×§×ª ××¡×¤×¨
            if (!isNaN(value) && !isNaN(parseFloat(value))) {
                numberCount++;
            }
            
            // ×‘×“×™×§×ª ×ª××¨×™×š
            if (!isNaN(Date.parse(value))) {
                dateCount++;
            }
            
            // ×‘×“×™×§×ª ×‘×•×œ×™×× ×™
            if (['true', 'false', '×›×Ÿ', '×œ×', '1', '0'].includes(strValue)) {
                booleanCount++;
            }
        });

        const threshold = samples.length * 0.7;
        
        if (numberCount >= threshold) return 'number';
        if (dateCount >= threshold) return 'date';
        if (booleanCount >= threshold) return 'boolean';
        
        return 'text';
    }

    getSampleValues(data, columnName) {
        return data.slice(0, 3)
            .map(row => row[columnName])
            .filter(value => value !== null && value !== undefined && value !== '');
    }

    countNullValues(data, columnName) {
        return data.filter(row => 
            !row[columnName] || row[columnName].toString().trim() === ''
        ).length;
    }

    countUniqueValues(data, columnName) {
        const uniqueValues = new Set();
        data.forEach(row => {
            const value = row[columnName];
            if (value !== null && value !== undefined && value !== '') {
                uniqueValues.add(value.toString());
            }
        });
        return uniqueValues.size;
    }

    // ğŸ¯ ×˜×™×¤×•×œ ×‘××™×¨×•×¢×™ ×§×œ×˜ ×§×•×‘×¥
    async handleFileInput(event, inputType) {
        const file = event.target.files[0];
        if (!file) return;

        console.log(`ğŸ“ × ×‘×—×¨ ×§×•×‘×¥: ${file.name} (${inputType})`);

        // ×¢×“×›×•×Ÿ UI ××ª××™×
        this.updateFileInputUI(inputType, 'loading', `×˜×•×¢×Ÿ ${file.name}...`);

        try {
            const result = await this.uploadFile(file, 
                (progress, message) => this.updateProgress(inputType, progress, message), 
                inputType
            );

            if (result.success) {
                this.updateFileInputUI(inputType, 'success', `âœ… ${file.name} × ×˜×¢×Ÿ ×‘×”×¦×œ×—×”`);
                
                // ×©××•×¨ ×‘×”×ª×× ×œ×¡×•×’ ×”×§×•×‘×¥
                this.saveFileData(inputType, result);
                
                utils.showNotification('×§×•×‘×¥ × ×˜×¢×Ÿ', `${file.name} × ×˜×¢×Ÿ ×‘×”×¦×œ×—×”`, 'success');
            } else {
                this.updateFileInputUI(inputType, 'error', `âŒ ×©×’×™××”: ${result.error}`);
                utils.showNotification('×©×’×™××” ×‘×˜×¢×™× ×”', result.error, 'error');
            }

        } catch (error) {
            console.error(`âŒ ×©×’×™××” ×‘×˜×¢×™× ×ª ${inputType}:`, error);
            this.updateFileInputUI(inputType, 'error', `âŒ ×©×’×™××”: ${error.message}`);
            utils.showNotification('×©×’×™××”', error.message, 'error');
        }
    }

    // ğŸ’¾ ×©××™×¨×ª × ×ª×•× ×™ ×§×•×‘×¥
    saveFileData(inputType, result) {
        switch (inputType) {
            case 'mainExcelFile':
                window.CreditSystem.excelData.main = result.data;
                break;
            case 'scoresFile':
                window.CreditSystem.excelData.scores = result.data;
                break;
            case 'returnedFile':
                window.CreditSystem.excelData.returned = result.data;
                break;
            case 'warningsFile':
                window.CreditSystem.excelData.warnings = result.data;
                break;
        }
    }

    // ğŸ¨ ×¢×“×›×•×Ÿ UI
    updateFileInputUI(inputType, status, message) {
        const statusMap = {
            'mainExcelFile': 'transactionsStatus',
            'scoresFile': 'returnedStatus',
            'returnedFile': 'returnedStatus', 
            'warningsFile': 'warningsStatus'
        };

        const elementId = statusMap[inputType];
        if (elementId) {
            const element = document.getElementById(elementId);
            if (element) {
                element.textContent = message;
                element.className = `status-${status}`;
            }
        }
    }

    updateProgress(inputType, progress, message) {
        console.log(`ğŸ“Š ${inputType}: ${progress}% - ${message}`);
        // ×›××Ÿ × ×™×ª×Ÿ ×œ×”×•×¡×™×£ ×¢×“×›×•×Ÿ ×•×™×–×•××œ×™ ×©×œ ×”×ª×§×“××•×ª
    }

    // ğŸ¯ ×˜×™×¤×•×œ ×‘-Drag & Drop
    handleDragOver(e) {
        e.preventDefault();
        e.stopPropagation();
        e.dataTransfer.dropEffect = 'copy';
    }

    handleDrop(e) {
        e.preventDefault();
        e.stopPropagation();
        
        const files = Array.from(e.dataTransfer.files);
        const uploadArea = e.target.closest('.upload-area, .excel-upload-section');
        
        if (uploadArea) {
            uploadArea.classList.remove('dragover');
            
            if (files.length > 0) {
                // ×˜×¢×Ÿ ××ª ×”×§×•×‘×¥ ×”×¨××©×•×Ÿ
                this.handleFileInput({ target: { files: files } }, 'mainExcelFile');
            }
        }
    }

    handleDragEnter(e) {
        const uploadArea = e.target.closest('.upload-area, .excel-upload-section');
        if (uploadArea) {
            uploadArea.classList.add('dragover');
        }
    }

    handleDragLeave(e) {
        const uploadArea = e.target.closest('.upload-area, .excel-upload-section');
        if (uploadArea && !uploadArea.contains(e.relatedTarget)) {
            uploadArea.classList.remove('dragover');
        }
    }

    // ğŸ”§ ×¤×•× ×§×¦×™×•×ª ×¢×–×¨ ×›×œ×œ×™×•×ª
    getFileExtension(fileName) {
        return fileName.substring(fileName.lastIndexOf('.')).toLowerCase();
    }

    formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    // ğŸ”„ ××™×¤×•×¡
    reset() {
        this.currentFile = null;
        this.uploadProgress = 0;
        window.CreditSystem.excelData = {};
    }

    // ğŸ“Š ×§×‘×œ×ª × ×ª×•× ×™×
    getCurrentData() {
        return window.CreditSystem.excelData;
    }
}

// ğŸŒ ×™×¦×™×¨×ª ××•×¤×¢ ×’×œ×•×‘×œ×™
window.fileLoader = new EnhancedFileLoader();

// ğŸ“¤ ×™×™×¦×•× ×œ××•×“×•×œ×™×
if (typeof module !== 'undefined' && module.exports) {
    module.exports = EnhancedFileLoader;
}
